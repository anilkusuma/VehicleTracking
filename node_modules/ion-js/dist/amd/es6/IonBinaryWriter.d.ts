import { Decimal } from "./IonDecimal";
import { LocalSymbolTable } from "./IonLocalSymbolTable";
import { LowLevelBinaryWriter } from "./IonLowLevelBinaryWriter";
import { Timestamp } from "./IonTimestamp";
import { TypeCodes } from "./IonBinary";
import { Writeable } from "./IonWriteable";
import { Writer } from "./IonWriter";
export declare class BinaryWriter implements Writer {
    getBytes(): number[];
    private readonly symbolTable;
    private readonly writer;
    private datagram;
    private containers;
    private fieldName;
    private state;
    constructor(symbolTable: LocalSymbolTable, writeable: Writeable);
    writeBlob(value: number[], annotations?: string[]): void;
    writeBoolean(value: boolean, annotations?: string[]): void;
    writeClob(value: number[], annotations?: string[]): void;
    writeDecimal(value: Decimal | string, annotations?: string[]): void;
    writeFloat32(value: number, annotations?: string[]): void;
    writeFloat64(value: number, annotations?: string[]): void;
    writeInt(value: number, annotations?: string[]): void;
    writeList(annotations?: string[], isNull?: boolean): void;
    writeNull(type_?: TypeCodes, annotations?: string[]): void;
    writeSexp(annotations?: string[], isNull?: boolean): void;
    writeString(value: string, annotations?: string[]): void;
    writeStruct(annotations?: string[], isNull?: boolean): void;
    writeSymbol(value: string, annotations?: string[]): void;
    writeTimestamp(value: Timestamp, annotations?: string[]): void;
    endContainer(): void;
    private writeIvm();
    writeFieldName(fieldName: string): void;
    private encodeAnnotations(annotations);
    private isTopLevel();
    private getCurrentContainer();
    private addNode(node);
    close(): void;
    private checkWriteValue();
    private checkClosed();
    private writeSymbolTable();
    private writeImport(import_);
}
export interface Node {
    isContainer(): boolean;
    addChild(child: Node, name?: number[]): void;
    write(): void;
    getLength(): number;
}
export declare abstract class AbstractNode implements Node {
    private readonly _writer;
    private readonly parent;
    private readonly _typeCode;
    private readonly annotations;
    constructor(_writer: LowLevelBinaryWriter, parent: Node, _typeCode: TypeCodes, annotations?: number[]);
    private hasAnnotations();
    writeTypeDescriptorAndLength(typeCode: TypeCodes, isNull: boolean, length: number): void;
    getLengthLength(length: number): number;
    getContainedValueLength(): number;
    abstract getValueLength(): number;
    getAnnotatedContainerLength(): number;
    isNull(): boolean;
    getAnnotationsLength(): number;
    getLength(): number;
    writeAnnotations(): void;
    readonly typeCode: number;
    readonly writer: LowLevelBinaryWriter;
    abstract isContainer(): boolean;
    abstract addChild(child: Node, name?: number[]): void;
    abstract write(): void;
}
export declare abstract class LeafNode extends AbstractNode {
    addChild(child: Node, name?: number[]): void;
    isContainer(): boolean;
}
export declare class NullNode extends LeafNode {
    constructor(writer: LowLevelBinaryWriter, parent: Node, typeCode: TypeCodes, annotations: number[]);
    write(): void;
    getValueLength(): number;
}
