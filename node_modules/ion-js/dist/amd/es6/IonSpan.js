define(["require", "exports", "./IonConstants"], function (require, exports, IonConstants_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const MAX_POS = 1024 * 1024 * 1024;
    const LINE_FEED = 10;
    const CARRIAGE_RETURN = 13;
    const DEBUG_FLAG = true;
    class StringSpan {
        constructor(src, start, len) {
            this._line = 1;
            this._src = src;
            this._pos = 0;
            this._limit = src.length;
            if (start !== undefined) {
                this._pos = start;
                if (len !== undefined) {
                    this._limit = start + len;
                }
            }
            this._start = this._pos;
            this._line_start = this._pos;
            this._old_line_start = 0;
        }
        position() {
            return this._pos - this._start;
        }
        getRemaining() {
            return this._limit - this._pos;
        }
        setRemaining(r) {
            this._limit = r + this._pos;
        }
        is_empty() {
            return (this._pos >= this._limit);
        }
        next() {
            var ch;
            if (this.is_empty()) {
                if (this._pos > MAX_POS) {
                    throw new Error("span position is out of bounds");
                }
                this._pos++;
                return IonConstants_1.EOF;
            }
            ch = this._src.charCodeAt(this._pos);
            if (ch === CARRIAGE_RETURN) {
                if (this.peek() != LINE_FEED) {
                    this._inc_line();
                }
            }
            else if (ch == LINE_FEED) {
                this._inc_line();
            }
            this._pos++;
            return ch;
        }
        _inc_line() {
            this._old_line_start = this._line_start;
            this._line++;
            this._line_start = this._pos;
        }
        unread(ch) {
            if (this._pos <= this._start)
                throw new Error("span error");
            this._pos--;
            if (ch < 0) {
                if (this.is_empty() != true)
                    throw new Error("span error");
                return;
            }
            if (this._pos == this._line_start) {
                this._line_start = this._old_line_start;
                this._line--;
            }
            if (ch != this.peek())
                throw new Error("span error");
        }
        peek() {
            return this.valueAt(this._pos);
        }
        skip(dist) {
            this._pos += dist;
            if (this._pos > this._limit) {
                this._pos = this._limit;
            }
        }
        valueAt(ii) {
            if (ii < this._start || ii >= this._limit)
                return IonConstants_1.EOF;
            return this._src.charCodeAt(ii);
        }
        charAt(ii) {
            if (ii < this._start || ii >= this._limit)
                return "";
            return this._src[ii];
        }
        offset() {
            return this._pos - this._line_start;
        }
        locator(pos) {
            let line = 1, column = 1;
            for (let i = 0; i < pos; i++) {
                let ch = this.valueAt(i);
                if (ch == LINE_FEED) {
                    line++;
                    column = 1;
                }
                else {
                    column++;
                }
            }
            return [line, column];
        }
        error_line(start, end) {
            let line_start = start;
            while (line_start > 0 && this.valueAt(line_start - 1) != LINE_FEED) {
                line_start--;
            }
            let line_end = end;
            while (line_end < this._limit && this.valueAt(line_end) != LINE_FEED) {
                line_end++;
            }
            let str = "";
            for (let x = line_start; x < line_end; x++) {
                str += this.charAt(x);
            }
            let pointer = "";
            for (var y = line_start; y < start; y++) {
                pointer += " ";
            }
            for (; y < end; y++)
                pointer += "^";
            return [str, pointer];
        }
        clone(start, len) {
            let actual_len = this._limit - this._pos - start;
            if (actual_len > len) {
                actual_len = len;
            }
            return new StringSpan(this._src, this._pos, actual_len);
        }
    }
    exports.StringSpan = StringSpan;
    class BinarySpan {
        constructor(src, start, len) {
            this._src = src;
            this._limit = src.length;
            this._start = start || 0;
            if (len !== undefined) {
                this._limit = start + len;
            }
            this._pos = this._start;
        }
        error_line(start, end) {
            throw new Error("not implemented on binary spans");
        }
        locator(pos) {
            throw new Error("not implemented on binary spans");
        }
        position() {
            return this._pos - this._start;
        }
        getRemaining() {
            return this._limit - this._pos;
        }
        setRemaining(r) {
            this._limit = r + this._pos;
        }
        is_empty() {
            return (this._pos >= this._limit);
        }
        next() {
            if (this.is_empty()) {
                if (this._pos > MAX_POS) {
                    throw new Error("span position is out of bounds");
                }
                this._pos++;
                return IonConstants_1.EOF;
            }
            let b = this._src[this._pos];
            this._pos++;
            return (b & 0xFF);
        }
        unread(b) {
            if (this._pos <= this._start)
                throw new Error("span error");
            this._pos--;
            if (b == IonConstants_1.EOF) {
                if (this.is_empty() == false)
                    throw new Error("span error");
            }
        }
        peek() {
            if (this.is_empty())
                return IonConstants_1.EOF;
            return (this._src[this._pos] & 0xFF);
        }
        skip(dist) {
            this._pos += dist;
            if (this._pos > this._limit) {
                this._pos = this._limit;
            }
        }
        valueAt(ii) {
            if (ii < this._start || ii >= this._limit)
                return undefined;
            return (this._src[ii] & 0xFF);
        }
        clone(start, len) {
            let actual_len = this._limit - this._pos - start;
            if (actual_len > len) {
                actual_len = len;
            }
            return new BinarySpan(this._src, this._pos + start, actual_len);
        }
        write(b) {
            throw new Error("not implemented");
        }
    }
    exports.BinarySpan = BinarySpan;
});
//# sourceMappingURL=IonSpan.js.map